{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,sBAAQ;AACrD,cAAc,mBAAO,CAAC,wDAAY;AAClC,mBAAmB,mBAAO,CAAC,wEAAc;AACzC,QAAQ,4CAA4C,EAAE,mBAAO,CAAC,gEAAa;AAC3E,QAAQ,oBAAoB,EAAE,mBAAO,CAAC,sDAAQ;;AAE9C;AACA,YAAY,MAAM,EAAE,qBAAqB;AACzC;;AAEA;AACA,aAAa;AACb,aAAa;AACb,UAAU,QAAQ;AAClB;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,cAAc,IAAI;AACpD,eAAe,oBAAoB,EAAE,KAAK,EAAE,wCAAwC;AACpF;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA,eAAe;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,6BAA6B,gDAAgD;AAC7E,eAAe;AACf;AACA,0BAA0B;AAC1B,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,QAAQ;AAC7B,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,mCAAmC,iBAAiB;AACpD,KAAK;AACL;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,oBAAoB,sDAAsD,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,iDAAiD,uBAAuB;AACxE;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,kDAAkD,SAAS;AAC3D;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,mDAAmD,yBAAyB;AAC5E;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,eAAe;AACf,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,eAAe;AACf,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,eAAe;AACf;AACA,2BAA2B,yBAAyB,IAAI;AACxD,4DAA4D,gCAAgC;AAC5F;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,eAAe;AACf;AACA,0BAA0B,UAAU,IAAI;AACxC,2DAA2D,yBAAyB;AACpF;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA,sCAAsC,UAAU;AAChD;AACA,KAAK;AACL,wDAAwD,iBAAiB;AACzE;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,uBAAuB,kCAAkC,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,8BAA8B,oBAAoB;AACvE,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnpBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAe;;AAEf,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjLa;;AAEb,aAAa,mBAAO,CAAC,sDAAQ;;AAE7B;AACA,UAAU,mBAAO,CAAC,0DAAU;AAC5B;AACA,oCAAoC,GAAG;AACvC,GAAG;AACH;;;;;;;;;;;;ACTa;;AAEb;AACA,OAAO,mBAAO,CAAC,+DAAO;AACtB,aAAa,mBAAO,CAAC,2EAAa;AAClC;;;;;;;;;;;;ACLa;;AAEb,YAAY,mBAAO,CAAC,gBAAK;AACzB,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,cAAc,mBAAO,CAAC,wDAAY;AAClC,QAAQ,OAAO,EAAE,mBAAO,CAAC,uDAAS;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA,UAAU,OAAO,uCAAuC;AACxD;AACA,YAAY,0BAA0B,eAAe,GAAG;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,eAAe,UAAU,GAAG;AAC5B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,qBAAqB;;;;;;;;;;;;AC5KR;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,QAAQ,UAAU,EAAE,mBAAO,CAAC,iEAAc;;AAE1C;AACA,+CAA+C,mBAAO,CAAC,iBAAI;;AAE3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,KAAK,kBAAkB,qBAAqB;AACpE,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAS;;AAEf;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AC5Ea;;AAEb;AACA;AACA,UAAU,MAAM,EAAE,mBAAO,CAAC,0BAAU;AACpC;AACA,EAAE;AACF;AACA,eAAe,mBAAO,CAAC,8BAAiB;AACxC,IAAI,aAAa;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDa;;AAEb;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC,kBAAe;AAChB;;AAEA,eAAe;AACf,eAAe;AACf,gBAAgB;;;;;;;;;;;;ACxBH;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,mBAAO,CAAC,4DAAa;AAC9C,qBAAqB,mBAAO,CAAC,8BAAY;AACzC,uCAAuC,mBAAO,CAAC,0CAAgB;AAC/D,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iEAAiE,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA,2DAA2D,eAAe,GAAG,QAAQ,uBAAuB,cAAc;AAC1H,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,4CAA4C;AAC1J;AACA;AACA,gBAAgB,qEAAqE;AACrF;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+BAA+B,wCAAwC,GAAG,eAAe,GAAG,8BAA8B;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO,eAAe,2CAA2C;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ,IAAI,WAAW;AACzF;AACA;AACA,uCAAuC,UAAU,oBAAoB,UAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC9RF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,mBAAO,CAAC,oBAAO;AAC/C,0BAA0B,mBAAO,CAAC,wCAAiB;AACnD,sBAAsB,mBAAO,CAAC,gCAAa;AAC3C,qBAAqB,mBAAO,CAAC,8BAAY;AACzC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA;AACA,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qEAAqE,eAAe;AACpF;AACA;AACA,qEAAqE,2CAA2C;AAChH;AACA,uEAAuE,4DAA4D;AACnI,qEAAqE,+DAA+D;AACpI,qEAAqE,+DAA+D;AACpI;AACA;AACA,2DAA2D,SAAS,mDAAmD;AACvH,+DAA+D,2CAA2C,QAAQ,GAAG,YAAY,2DAA2D,oBAAoB;AAChN,6DAA6D,UAAU,eAAe,GAAG,QAAQ,IAAI;AACrG;AACA;AACA,iDAAiD,mCAAmC;AACpF;AACA,kBAAe;;;;;;;;;;;;ACrCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,0BAA0B,GAAG,qBAAqB;AAC3E,oBAAoB,mBAAO,CAAC,4BAAW;AACvC,qBAAqB,+EAA+E,YAAY;AAChH,0BAA0B,8EAA8E,UAAU;AAClH,sBAAsB,sEAAsE,MAAM;;;;;;;;;;;;;;;;;;;;;;;ACNrF;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,8BAAY;AACzC,gCAAgC,mBAAO,CAAC,qCAAY;AACpD,qCAAqC,mBAAO,CAAC,yCAAc;AAC3D,mCAAmC,mBAAO,CAAC,sCAAY;AACvD;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;;;;;;;;;;;;AChDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAe;;;;;;;;;;;AChCf,e;;;;;;;;;;ACAA,e;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,4C;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,uC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UE5BA;UACA;UACA;UACA","sources":["webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/client.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/constants.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/index.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/transports/index.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/transports/ipc.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/transports/websocket.js","webpack://vortex-discord-rich-presence/./node_modules/discord-rpc/src/util.js","webpack://vortex-discord-rich-presence/./node_modules/node-fetch/browser.js","webpack://vortex-discord-rich-presence/./src/DiscordRPC.ts","webpack://vortex-discord-rich-presence/./src/Settings.tsx","webpack://vortex-discord-rich-presence/./src/actions.ts","webpack://vortex-discord-rich-presence/./src/index.ts","webpack://vortex-discord-rich-presence/./src/reducers.ts","webpack://vortex-discord-rich-presence/ignored|C:\\Users\\MikeW\\Documents\\GitHub\\vortex-discord-rich-presence\\node_modules\\discord-rpc\\src|register-scheme","webpack://vortex-discord-rich-presence/ignored|C:\\Users\\MikeW\\Documents\\GitHub\\vortex-discord-rich-presence\\node_modules\\discord-rpc\\src\\transports|ws","webpack://vortex-discord-rich-presence/external commonjs2 \"electron\"","webpack://vortex-discord-rich-presence/external node-commonjs \"events\"","webpack://vortex-discord-rich-presence/external commonjs2 \"net\"","webpack://vortex-discord-rich-presence/external commonjs2 \"react\"","webpack://vortex-discord-rich-presence/external commonjs2 \"react-bootstrap\"","webpack://vortex-discord-rich-presence/external commonjs2 \"react-redux\"","webpack://vortex-discord-rich-presence/external commonjs2 \"redux-act\"","webpack://vortex-discord-rich-presence/external node-commonjs \"timers\"","webpack://vortex-discord-rich-presence/external commonjs2 \"vortex-api\"","webpack://vortex-discord-rich-presence/webpack/bootstrap","webpack://vortex-discord-rich-presence/webpack/before-startup","webpack://vortex-discord-rich-presence/webpack/startup","webpack://vortex-discord-rich-presence/webpack/after-startup"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst { setTimeout, clearTimeout } = require('timers');\nconst fetch = require('node-fetch');\nconst transports = require('./transports');\nconst { RPCCommands, RPCEvents, RelationshipTypes } = require('./constants');\nconst { pid: getPid, uuid } = require('./util');\n\nfunction subKey(event, args) {\n  return `${event}${JSON.stringify(args)}`;\n}\n\n/**\n * @typedef {RPCClientOptions}\n * @extends {ClientOptions}\n * @prop {string} transport RPC transport. one of `ipc` or `websocket`\n */\n\n/**\n * The main hub for interacting with Discord RPC\n * @extends {BaseClient}\n */\nclass RPCClient extends EventEmitter {\n  /**\n   * @param {RPCClientOptions} [options] Options for the client.\n   * You must provide a transport\n   */\n  constructor(options = {}) {\n    super();\n\n    this.options = options;\n\n    this.accessToken = null;\n    this.clientId = null;\n\n    /**\n     * Application used in this client\n     * @type {?ClientApplication}\n     */\n    this.application = null;\n\n    /**\n     * User used in this application\n     * @type {?User}\n     */\n    this.user = null;\n\n    const Transport = transports[options.transport];\n    if (!Transport) {\n      throw new TypeError('RPC_INVALID_TRANSPORT', options.transport);\n    }\n\n    this.fetch = (method, path, { data, query } = {}) =>\n      fetch(`${this.fetch.endpoint}${path}${query ? new URLSearchParams(query) : ''}`, {\n        method,\n        body: data,\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n        },\n      }).then(async (r) => {\n        const body = await r.json();\n        if (!r.ok) {\n          const e = new Error(r.status);\n          e.body = body;\n          throw e;\n        }\n        return body;\n      });\n\n    this.fetch.endpoint = 'https://discord.com/api';\n\n    /**\n     * Raw transport userd\n     * @type {RPCTransport}\n     * @private\n     */\n    this.transport = new Transport(this);\n    this.transport.on('message', this._onRpcMessage.bind(this));\n\n    /**\n     * Map of nonces being expected from the transport\n     * @type {Map}\n     * @private\n     */\n    this._expecting = new Map();\n\n    this._connectPromise = undefined;\n  }\n\n  /**\n   * Search and connect to RPC\n   */\n  connect(clientId) {\n    if (this._connectPromise) {\n      return this._connectPromise;\n    }\n    this._connectPromise = new Promise((resolve, reject) => {\n      this.clientId = clientId;\n      const timeout = setTimeout(() => reject(new Error('RPC_CONNECTION_TIMEOUT')), 10e3);\n      timeout.unref();\n      this.once('connected', () => {\n        clearTimeout(timeout);\n        resolve(this);\n      });\n      this.transport.once('close', () => {\n        this._expecting.forEach((e) => {\n          e.reject(new Error('connection closed'));\n        });\n        this.emit('disconnected');\n        reject(new Error('connection closed'));\n      });\n      this.transport.connect().catch(reject);\n    });\n    return this._connectPromise;\n  }\n\n  /**\n   * @typedef {RPCLoginOptions}\n   * @param {string} clientId Client ID\n   * @param {string} [clientSecret] Client secret\n   * @param {string} [accessToken] Access token\n   * @param {string} [rpcToken] RPC token\n   * @param {string} [tokenEndpoint] Token endpoint\n   * @param {string[]} [scopes] Scopes to authorize with\n   */\n\n  /**\n   * Performs authentication flow. Automatically calls Client#connect if needed.\n   * @param {RPCLoginOptions} options Options for authentication.\n   * At least one property must be provided to perform login.\n   * @example client.login({ clientId: '1234567', clientSecret: 'abcdef123' });\n   * @returns {Promise<RPCClient>}\n   */\n  async login(options = {}) {\n    let { clientId, accessToken } = options;\n    await this.connect(clientId);\n    if (!options.scopes) {\n      this.emit('ready');\n      return this;\n    }\n    if (!accessToken) {\n      accessToken = await this.authorize(options);\n    }\n    return this.authenticate(accessToken);\n  }\n\n  /**\n   * Request\n   * @param {string} cmd Command\n   * @param {Object} [args={}] Arguments\n   * @param {string} [evt] Event\n   * @returns {Promise}\n   * @private\n   */\n  request(cmd, args, evt) {\n    return new Promise((resolve, reject) => {\n      const nonce = uuid();\n      this.transport.send({ cmd, args, evt, nonce });\n      this._expecting.set(nonce, { resolve, reject });\n    });\n  }\n\n  /**\n   * Message handler\n   * @param {Object} message message\n   * @private\n   */\n  _onRpcMessage(message) {\n    if (message.cmd === RPCCommands.DISPATCH && message.evt === RPCEvents.READY) {\n      if (message.data.user) {\n        this.user = message.data.user;\n      }\n      this.emit('connected');\n    } else if (this._expecting.has(message.nonce)) {\n      const { resolve, reject } = this._expecting.get(message.nonce);\n      if (message.evt === 'ERROR') {\n        const e = new Error(message.data.message);\n        e.code = message.data.code;\n        e.data = message.data;\n        reject(e);\n      } else {\n        resolve(message.data);\n      }\n      this._expecting.delete(message.nonce);\n    } else {\n      this.emit(message.evt, message.data);\n    }\n  }\n\n  /**\n   * Authorize\n   * @param {Object} options options\n   * @returns {Promise}\n   * @private\n   */\n  async authorize({ scopes, clientSecret, rpcToken, redirectUri, prompt } = {}) {\n    if (clientSecret && rpcToken === true) {\n      const body = await this.fetch('POST', '/oauth2/token/rpc', {\n        data: new URLSearchParams({\n          client_id: this.clientId,\n          client_secret: clientSecret,\n        }),\n      });\n      rpcToken = body.rpc_token;\n    }\n\n    const { code } = await this.request('AUTHORIZE', {\n      scopes,\n      client_id: this.clientId,\n      prompt,\n      rpc_token: rpcToken,\n    });\n\n    const response = await this.fetch('POST', '/oauth2/token', {\n      data: new URLSearchParams({\n        client_id: this.clientId,\n        client_secret: clientSecret,\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: redirectUri,\n      }),\n    });\n\n    return response.access_token;\n  }\n\n  /**\n   * Authenticate\n   * @param {string} accessToken access token\n   * @returns {Promise}\n   * @private\n   */\n  authenticate(accessToken) {\n    return this.request('AUTHENTICATE', { access_token: accessToken })\n      .then(({ application, user }) => {\n        this.accessToken = accessToken;\n        this.application = application;\n        this.user = user;\n        this.emit('ready');\n        return this;\n      });\n  }\n\n\n  /**\n   * Fetch a guild\n   * @param {Snowflake} id Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Guild>}\n   */\n  getGuild(id, timeout) {\n    return this.request(RPCCommands.GET_GUILD, { guild_id: id, timeout });\n  }\n\n  /**\n   * Fetch all guilds\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Guild>>}\n   */\n  getGuilds(timeout) {\n    return this.request(RPCCommands.GET_GUILDS, { timeout });\n  }\n\n  /**\n   * Get a channel\n   * @param {Snowflake} id Channel ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Channel>}\n   */\n  getChannel(id, timeout) {\n    return this.request(RPCCommands.GET_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get all channels\n   * @param {Snowflake} [id] Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Channel>>}\n   */\n  async getChannels(id, timeout) {\n    const { channels } = await this.request(RPCCommands.GET_CHANNELS, {\n      timeout,\n      guild_id: id,\n    });\n    return channels;\n  }\n\n  /**\n   * @typedef {CertifiedDevice}\n   * @prop {string} type One of `AUDIO_INPUT`, `AUDIO_OUTPUT`, `VIDEO_INPUT`\n   * @prop {string} uuid This device's Windows UUID\n   * @prop {object} vendor Vendor information\n   * @prop {string} vendor.name Vendor's name\n   * @prop {string} vendor.url Vendor's url\n   * @prop {object} model Model information\n   * @prop {string} model.name Model's name\n   * @prop {string} model.url Model's url\n   * @prop {string[]} related Array of related product's Windows UUIDs\n   * @prop {boolean} echoCancellation If the device has echo cancellation\n   * @prop {boolean} noiseSuppression If the device has noise suppression\n   * @prop {boolean} automaticGainControl If the device has automatic gain control\n   * @prop {boolean} hardwareMute If the device has a hardware mute\n   */\n\n  /**\n   * Tell discord which devices are certified\n   * @param {CertifiedDevice[]} devices Certified devices to send to discord\n   * @returns {Promise}\n   */\n  setCertifiedDevices(devices) {\n    return this.request(RPCCommands.SET_CERTIFIED_DEVICES, {\n      devices: devices.map((d) => ({\n        type: d.type,\n        id: d.uuid,\n        vendor: d.vendor,\n        model: d.model,\n        related: d.related,\n        echo_cancellation: d.echoCancellation,\n        noise_suppression: d.noiseSuppression,\n        automatic_gain_control: d.automaticGainControl,\n        hardware_mute: d.hardwareMute,\n      })),\n    });\n  }\n\n  /**\n   * @typedef {UserVoiceSettings}\n   * @prop {Snowflake} id ID of the user these settings apply to\n   * @prop {?Object} [pan] Pan settings, an object with `left` and `right` set between\n   * 0.0 and 1.0, inclusive\n   * @prop {?number} [volume=100] The volume\n   * @prop {bool} [mute] If the user is muted\n   */\n\n  /**\n   * Set the voice settings for a user, by id\n   * @param {Snowflake} id ID of the user to set\n   * @param {UserVoiceSettings} settings Settings\n   * @returns {Promise}\n   */\n  setUserVoiceSettings(id, settings) {\n    return this.request(RPCCommands.SET_USER_VOICE_SETTINGS, {\n      user_id: id,\n      pan: settings.pan,\n      mute: settings.mute,\n      volume: settings.volume,\n    });\n  }\n\n  /**\n   * Move the user to a voice channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * @param {boolean} [options.force] Force this move. This should only be done if you\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectVoiceChannel(id, { timeout, force = false } = {}) {\n    return this.request(RPCCommands.SELECT_VOICE_CHANNEL, { channel_id: id, timeout, force });\n  }\n\n  /**\n   * Move the user to a text channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectTextChannel(id, { timeout } = {}) {\n    return this.request(RPCCommands.SELECT_TEXT_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get current voice settings\n   * @returns {Promise}\n   */\n  getVoiceSettings() {\n    return this.request(RPCCommands.GET_VOICE_SETTINGS)\n      .then((s) => ({\n        automaticGainControl: s.automatic_gain_control,\n        echoCancellation: s.echo_cancellation,\n        noiseSuppression: s.noise_suppression,\n        qos: s.qos,\n        silenceWarning: s.silence_warning,\n        deaf: s.deaf,\n        mute: s.mute,\n        input: {\n          availableDevices: s.input.available_devices,\n          device: s.input.device_id,\n          volume: s.input.volume,\n        },\n        output: {\n          availableDevices: s.output.available_devices,\n          device: s.output.device_id,\n          volume: s.output.volume,\n        },\n        mode: {\n          type: s.mode.type,\n          autoThreshold: s.mode.auto_threshold,\n          threshold: s.mode.threshold,\n          shortcut: s.mode.shortcut,\n          delay: s.mode.delay,\n        },\n      }));\n  }\n\n  /**\n   * Set current voice settings, overriding the current settings until this session disconnects.\n   * This also locks the settings for any other rpc sessions which may be connected.\n   * @param {Object} args Settings\n   * @returns {Promise}\n   */\n  setVoiceSettings(args) {\n    return this.request(RPCCommands.SET_VOICE_SETTINGS, {\n      automatic_gain_control: args.automaticGainControl,\n      echo_cancellation: args.echoCancellation,\n      noise_suppression: args.noiseSuppression,\n      qos: args.qos,\n      silence_warning: args.silenceWarning,\n      deaf: args.deaf,\n      mute: args.mute,\n      input: args.input ? {\n        device_id: args.input.device,\n        volume: args.input.volume,\n      } : undefined,\n      output: args.output ? {\n        device_id: args.output.device,\n        volume: args.output.volume,\n      } : undefined,\n      mode: args.mode ? {\n        type: args.mode.type,\n        auto_threshold: args.mode.autoThreshold,\n        threshold: args.mode.threshold,\n        shortcut: args.mode.shortcut,\n        delay: args.mode.delay,\n      } : undefined,\n    });\n  }\n\n  /**\n   * Capture a shortcut using the client\n   * The callback takes (key, stop) where `stop` is a function that will stop capturing.\n   * This `stop` function must be called before disconnecting or else the user will have\n   * to restart their client.\n   * @param {Function} callback Callback handling keys\n   * @returns {Promise<Function>}\n   */\n  captureShortcut(callback) {\n    const subid = subKey(RPCEvents.CAPTURE_SHORTCUT_CHANGE);\n    const stop = () => {\n      this._subscriptions.delete(subid);\n      return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'STOP' });\n    };\n    this._subscriptions.set(subid, ({ shortcut }) => {\n      callback(shortcut, stop);\n    });\n    return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'START' })\n      .then(() => stop);\n  }\n\n  /**\n   * Sets the presence for the logged in user.\n   * @param {object} args The rich presence to pass.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  setActivity(args = {}, pid = getPid()) {\n    let timestamps;\n    let assets;\n    let party;\n    let secrets;\n    if (args.startTimestamp || args.endTimestamp) {\n      timestamps = {\n        start: args.startTimestamp,\n        end: args.endTimestamp,\n      };\n      if (timestamps.start instanceof Date) {\n        timestamps.start = Math.round(timestamps.start.getTime());\n      }\n      if (timestamps.end instanceof Date) {\n        timestamps.end = Math.round(timestamps.end.getTime());\n      }\n      if (timestamps.start > 2147483647000) {\n        throw new RangeError('timestamps.start must fit into a unix timestamp');\n      }\n      if (timestamps.end > 2147483647000) {\n        throw new RangeError('timestamps.end must fit into a unix timestamp');\n      }\n    }\n    if (\n      args.largeImageKey || args.largeImageText\n      || args.smallImageKey || args.smallImageText\n    ) {\n      assets = {\n        large_image: args.largeImageKey,\n        large_text: args.largeImageText,\n        small_image: args.smallImageKey,\n        small_text: args.smallImageText,\n      };\n    }\n    if (args.partySize || args.partyId || args.partyMax) {\n      party = { id: args.partyId };\n      if (args.partySize || args.partyMax) {\n        party.size = [args.partySize, args.partyMax];\n      }\n    }\n    if (args.matchSecret || args.joinSecret || args.spectateSecret) {\n      secrets = {\n        match: args.matchSecret,\n        join: args.joinSecret,\n        spectate: args.spectateSecret,\n      };\n    }\n\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n      activity: {\n        state: args.state,\n        details: args.details,\n        timestamps,\n        assets,\n        party,\n        secrets,\n        buttons: args.buttons,\n        instance: !!args.instance,\n      },\n    });\n  }\n\n  /**\n   * Clears the currently set presence, if any. This will hide the \"Playing X\" message\n   * displayed below the user's name.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  clearActivity(pid = getPid()) {\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n    });\n  }\n\n  /**\n   * Invite a user to join the game the RPC user is currently playing\n   * @param {User} user The user to invite\n   * @returns {Promise}\n   */\n  sendJoinInvite(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_INVITE, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Request to join the game the user is playing\n   * @param {User} user The user whose game you want to request to join\n   * @returns {Promise}\n   */\n  sendJoinRequest(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Reject a join request from a user\n   * @param {User} user The user whose request you wish to reject\n   * @returns {Promise}\n   */\n  closeJoinRequest(user) {\n    return this.request(RPCCommands.CLOSE_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  createLobby(type, capacity, metadata) {\n    return this.request(RPCCommands.CREATE_LOBBY, {\n      type,\n      capacity,\n      metadata,\n    });\n  }\n\n  updateLobby(lobby, { type, owner, capacity, metadata } = {}) {\n    return this.request(RPCCommands.UPDATE_LOBBY, {\n      id: lobby.id || lobby,\n      type,\n      owner_id: (owner && owner.id) || owner,\n      capacity,\n      metadata,\n    });\n  }\n\n  deleteLobby(lobby) {\n    return this.request(RPCCommands.DELETE_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  connectToLobby(id, secret) {\n    return this.request(RPCCommands.CONNECT_TO_LOBBY, {\n      id,\n      secret,\n    });\n  }\n\n  sendToLobby(lobby, data) {\n    return this.request(RPCCommands.SEND_TO_LOBBY, {\n      id: lobby.id || lobby,\n      data,\n    });\n  }\n\n  disconnectFromLobby(lobby) {\n    return this.request(RPCCommands.DISCONNECT_FROM_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  updateLobbyMember(lobby, user, metadata) {\n    return this.request(RPCCommands.UPDATE_LOBBY_MEMBER, {\n      lobby_id: lobby.id || lobby,\n      user_id: user.id || user,\n      metadata,\n    });\n  }\n\n  getRelationships() {\n    const types = Object.keys(RelationshipTypes);\n    return this.request(RPCCommands.GET_RELATIONSHIPS)\n      .then((o) => o.relationships.map((r) => ({\n        ...r,\n        type: types[r.type],\n      })));\n  }\n\n  /**\n   * Subscribe to an event\n   * @param {string} event Name of event e.g. `MESSAGE_CREATE`\n   * @param {Object} [args] Args for event e.g. `{ channel_id: '1234' }`\n   * @returns {Promise<Object>}\n   */\n  async subscribe(event, args) {\n    await this.request(RPCCommands.SUBSCRIBE, args, event);\n    return {\n      unsubscribe: () => this.request(RPCCommands.UNSUBSCRIBE, args, event),\n    };\n  }\n\n  /**\n   * Destroy the client\n   */\n  async destroy() {\n    await this.transport.close();\n  }\n}\n\nmodule.exports = RPCClient;\n","'use strict';\n\nfunction keyMirror(arr) {\n  const tmp = {};\n  for (const value of arr) {\n    tmp[value] = value;\n  }\n  return tmp;\n}\n\n\nexports.browser = typeof window !== 'undefined';\n\nexports.RPCCommands = keyMirror([\n  'DISPATCH',\n  'AUTHORIZE',\n  'AUTHENTICATE',\n  'GET_GUILD',\n  'GET_GUILDS',\n  'GET_CHANNEL',\n  'GET_CHANNELS',\n  'CREATE_CHANNEL_INVITE',\n  'GET_RELATIONSHIPS',\n  'GET_USER',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'SET_USER_VOICE_SETTINGS',\n  'SET_USER_VOICE_SETTINGS_2',\n  'SELECT_VOICE_CHANNEL',\n  'GET_SELECTED_VOICE_CHANNEL',\n  'SELECT_TEXT_CHANNEL',\n  'GET_VOICE_SETTINGS',\n  'SET_VOICE_SETTINGS_2',\n  'SET_VOICE_SETTINGS',\n  'CAPTURE_SHORTCUT',\n  'SET_ACTIVITY',\n  'SEND_ACTIVITY_JOIN_INVITE',\n  'CLOSE_ACTIVITY_JOIN_REQUEST',\n  'ACTIVITY_INVITE_USER',\n  'ACCEPT_ACTIVITY_INVITE',\n  'INVITE_BROWSER',\n  'DEEP_LINK',\n  'CONNECTIONS_CALLBACK',\n  'BRAINTREE_POPUP_BRIDGE_CALLBACK',\n  'GIFT_CODE_BROWSER',\n  'GUILD_TEMPLATE_BROWSER',\n  'OVERLAY',\n  'BROWSER_HANDOFF',\n  'SET_CERTIFIED_DEVICES',\n  'GET_IMAGE',\n  'CREATE_LOBBY',\n  'UPDATE_LOBBY',\n  'DELETE_LOBBY',\n  'UPDATE_LOBBY_MEMBER',\n  'CONNECT_TO_LOBBY',\n  'DISCONNECT_FROM_LOBBY',\n  'SEND_TO_LOBBY',\n  'SEARCH_LOBBIES',\n  'CONNECT_TO_LOBBY_VOICE',\n  'DISCONNECT_FROM_LOBBY_VOICE',\n  'SET_OVERLAY_LOCKED',\n  'OPEN_OVERLAY_ACTIVITY_INVITE',\n  'OPEN_OVERLAY_GUILD_INVITE',\n  'OPEN_OVERLAY_VOICE_SETTINGS',\n  'VALIDATE_APPLICATION',\n  'GET_ENTITLEMENT_TICKET',\n  'GET_APPLICATION_TICKET',\n  'START_PURCHASE',\n  'GET_SKUS',\n  'GET_ENTITLEMENTS',\n  'GET_NETWORKING_CONFIG',\n  'NETWORKING_SYSTEM_METRICS',\n  'NETWORKING_PEER_METRICS',\n  'NETWORKING_CREATE_TOKEN',\n  'SET_USER_ACHIEVEMENT',\n  'GET_USER_ACHIEVEMENTS',\n]);\n\nexports.RPCEvents = keyMirror([\n  'CURRENT_USER_UPDATE',\n  'GUILD_STATUS',\n  'GUILD_CREATE',\n  'CHANNEL_CREATE',\n  'RELATIONSHIP_UPDATE',\n  'VOICE_CHANNEL_SELECT',\n  'VOICE_STATE_CREATE',\n  'VOICE_STATE_DELETE',\n  'VOICE_STATE_UPDATE',\n  'VOICE_SETTINGS_UPDATE',\n  'VOICE_SETTINGS_UPDATE_2',\n  'VOICE_CONNECTION_STATUS',\n  'SPEAKING_START',\n  'SPEAKING_STOP',\n  'GAME_JOIN',\n  'GAME_SPECTATE',\n  'ACTIVITY_JOIN',\n  'ACTIVITY_JOIN_REQUEST',\n  'ACTIVITY_SPECTATE',\n  'ACTIVITY_INVITE',\n  'NOTIFICATION_CREATE',\n  'MESSAGE_CREATE',\n  'MESSAGE_UPDATE',\n  'MESSAGE_DELETE',\n  'LOBBY_DELETE',\n  'LOBBY_UPDATE',\n  'LOBBY_MEMBER_CONNECT',\n  'LOBBY_MEMBER_DISCONNECT',\n  'LOBBY_MEMBER_UPDATE',\n  'LOBBY_MESSAGE',\n  'CAPTURE_SHORTCUT_CHANGE',\n  'OVERLAY',\n  'OVERLAY_UPDATE',\n  'ENTITLEMENT_CREATE',\n  'ENTITLEMENT_DELETE',\n  'USER_ACHIEVEMENT_UPDATE',\n  'READY',\n  'ERROR',\n]);\n\nexports.RPCErrors = {\n  CAPTURE_SHORTCUT_ALREADY_LISTENING: 5004,\n  GET_GUILD_TIMED_OUT: 5002,\n  INVALID_ACTIVITY_JOIN_REQUEST: 4012,\n  INVALID_ACTIVITY_SECRET: 5005,\n  INVALID_CHANNEL: 4005,\n  INVALID_CLIENTID: 4007,\n  INVALID_COMMAND: 4002,\n  INVALID_ENTITLEMENT: 4015,\n  INVALID_EVENT: 4004,\n  INVALID_GIFT_CODE: 4016,\n  INVALID_GUILD: 4003,\n  INVALID_INVITE: 4011,\n  INVALID_LOBBY: 4013,\n  INVALID_LOBBY_SECRET: 4014,\n  INVALID_ORIGIN: 4008,\n  INVALID_PAYLOAD: 4000,\n  INVALID_PERMISSIONS: 4006,\n  INVALID_TOKEN: 4009,\n  INVALID_USER: 4010,\n  LOBBY_FULL: 5007,\n  NO_ELIGIBLE_ACTIVITY: 5006,\n  OAUTH2_ERROR: 5000,\n  PURCHASE_CANCELED: 5008,\n  PURCHASE_ERROR: 5009,\n  RATE_LIMITED: 5011,\n  SELECT_CHANNEL_TIMED_OUT: 5001,\n  SELECT_VOICE_FORCE_REQUIRED: 5003,\n  SERVICE_UNAVAILABLE: 1001,\n  TRANSACTION_ABORTED: 1002,\n  UNAUTHORIZED_FOR_ACHIEVEMENT: 5010,\n  UNKNOWN_ERROR: 1000,\n};\n\nexports.RPCCloseCodes = {\n  CLOSE_NORMAL: 1000,\n  CLOSE_UNSUPPORTED: 1003,\n  CLOSE_ABNORMAL: 1006,\n  INVALID_CLIENTID: 4000,\n  INVALID_ORIGIN: 4001,\n  RATELIMITED: 4002,\n  TOKEN_REVOKED: 4003,\n  INVALID_VERSION: 4004,\n  INVALID_ENCODING: 4005,\n};\n\nexports.LobbyTypes = {\n  PRIVATE: 1,\n  PUBLIC: 2,\n};\n\nexports.RelationshipTypes = {\n  NONE: 0,\n  FRIEND: 1,\n  BLOCKED: 2,\n  PENDING_INCOMING: 3,\n  PENDING_OUTGOING: 4,\n  IMPLICIT: 5,\n};\n","'use strict';\n\nconst util = require('./util');\n\nmodule.exports = {\n  Client: require('./client'),\n  register(id) {\n    return util.register(`discord-${id}`);\n  },\n};\n","'use strict';\n\nmodule.exports = {\n  ipc: require('./ipc'),\n  websocket: require('./websocket'),\n};\n","'use strict';\n\nconst net = require('net');\nconst EventEmitter = require('events');\nconst fetch = require('node-fetch');\nconst { uuid } = require('../util');\n\nconst OPCodes = {\n  HANDSHAKE: 0,\n  FRAME: 1,\n  CLOSE: 2,\n  PING: 3,\n  PONG: 4,\n};\n\nfunction getIPCPath(id) {\n  if (process.platform === 'win32') {\n    return `\\\\\\\\?\\\\pipe\\\\discord-ipc-${id}`;\n  }\n  const { env: { XDG_RUNTIME_DIR, TMPDIR, TMP, TEMP } } = process;\n  const prefix = XDG_RUNTIME_DIR || TMPDIR || TMP || TEMP || '/tmp';\n  return `${prefix.replace(/\\/$/, '')}/discord-ipc-${id}`;\n}\n\nfunction getIPC(id = 0) {\n  return new Promise((resolve, reject) => {\n    const path = getIPCPath(id);\n    const onerror = () => {\n      if (id < 10) {\n        resolve(getIPC(id + 1));\n      } else {\n        reject(new Error('Could not connect'));\n      }\n    };\n    const sock = net.createConnection(path, () => {\n      sock.removeListener('error', onerror);\n      resolve(sock);\n    });\n    sock.once('error', onerror);\n  });\n}\n\nasync function findEndpoint(tries = 0) {\n  if (tries > 30) {\n    throw new Error('Could not find endpoint');\n  }\n  const endpoint = `http://127.0.0.1:${6463 + (tries % 10)}`;\n  try {\n    const r = await fetch(endpoint);\n    if (r.status === 404) {\n      return endpoint;\n    }\n    return findEndpoint(tries + 1);\n  } catch (e) {\n    return findEndpoint(tries + 1);\n  }\n}\n\nfunction encode(op, data) {\n  data = JSON.stringify(data);\n  const len = Buffer.byteLength(data);\n  const packet = Buffer.alloc(8 + len);\n  packet.writeInt32LE(op, 0);\n  packet.writeInt32LE(len, 4);\n  packet.write(data, 8, len);\n  return packet;\n}\n\nconst working = {\n  full: '',\n  op: undefined,\n};\n\nfunction decode(socket, callback) {\n  const packet = socket.read();\n  if (!packet) {\n    return;\n  }\n\n  let { op } = working;\n  let raw;\n  if (working.full === '') {\n    op = working.op = packet.readInt32LE(0);\n    const len = packet.readInt32LE(4);\n    raw = packet.slice(8, len + 8);\n  } else {\n    raw = packet.toString();\n  }\n\n  try {\n    const data = JSON.parse(working.full + raw);\n    callback({ op, data }); // eslint-disable-line callback-return\n    working.full = '';\n    working.op = undefined;\n  } catch (err) {\n    working.full += raw;\n  }\n\n  decode(socket, callback);\n}\n\nclass IPCTransport extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.socket = null;\n  }\n\n  async connect() {\n    const socket = this.socket = await getIPC();\n    socket.on('close', this.onClose.bind(this));\n    socket.on('error', this.onClose.bind(this));\n    this.emit('open');\n    socket.write(encode(OPCodes.HANDSHAKE, {\n      v: 1,\n      client_id: this.client.clientId,\n    }));\n    socket.pause();\n    socket.on('readable', () => {\n      decode(socket, ({ op, data }) => {\n        switch (op) {\n          case OPCodes.PING:\n            this.send(data, OPCodes.PONG);\n            break;\n          case OPCodes.FRAME:\n            if (!data) {\n              return;\n            }\n            if (data.cmd === 'AUTHORIZE' && data.evt !== 'ERROR') {\n              findEndpoint()\n                .then((endpoint) => {\n                  this.client.request.endpoint = endpoint;\n                })\n                .catch((e) => {\n                  this.client.emit('error', e);\n                });\n            }\n            this.emit('message', data);\n            break;\n          case OPCodes.CLOSE:\n            this.emit('close', data);\n            break;\n          default:\n            break;\n        }\n      });\n    });\n  }\n\n  onClose(e) {\n    this.emit('close', e);\n  }\n\n  send(data, op = OPCodes.FRAME) {\n    this.socket.write(encode(op, data));\n  }\n\n  async close() {\n    return new Promise((r) => {\n      this.once('close', r);\n      this.send({}, OPCodes.CLOSE);\n      this.socket.end();\n    });\n  }\n\n  ping() {\n    this.send(uuid(), OPCodes.PING);\n  }\n}\n\nmodule.exports = IPCTransport;\nmodule.exports.encode = encode;\nmodule.exports.decode = decode;\n","'use strict';\n\nconst EventEmitter = require('events');\nconst { browser } = require('../constants');\n\n// eslint-disable-next-line\nconst WebSocket = browser ? window.WebSocket : require('ws');\n\nconst pack = (d) => JSON.stringify(d);\nconst unpack = (s) => JSON.parse(s);\n\nclass WebSocketTransport extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.ws = null;\n    this.tries = 0;\n  }\n\n  async connect() {\n    const port = 6463 + (this.tries % 10);\n    this.tries += 1;\n\n    this.ws = new WebSocket(\n      `ws://127.0.0.1:${port}/?v=1&client_id=${this.client.clientId}`,\n      browser ? undefined : { origin: this.client.options.origin },\n    );\n    this.ws.onopen = this.onOpen.bind(this);\n    this.ws.onclose = this.onClose.bind(this);\n    this.ws.onerror = this.onError.bind(this);\n    this.ws.onmessage = this.onMessage.bind(this);\n  }\n\n  onOpen() {\n    this.emit('open');\n  }\n\n  onClose(event) {\n    if (!event.wasClean) {\n      return;\n    }\n    this.emit('close', event);\n  }\n\n  onError(event) {\n    try {\n      this.ws.close();\n    } catch {} // eslint-disable-line no-empty\n\n    if (this.tries > 20) {\n      this.emit('error', event.error);\n    } else {\n      setTimeout(() => {\n        this.connect();\n      }, 250);\n    }\n  }\n\n  onMessage(event) {\n    this.emit('message', unpack(event.data));\n  }\n\n  send(data) {\n    this.ws.send(pack(data));\n  }\n\n  ping() {} // eslint-disable-line no-empty-function\n\n  close() {\n    return new Promise((r) => {\n      this.once('close', r);\n      this.ws.close();\n    });\n  }\n}\n\nmodule.exports = WebSocketTransport;\n","'use strict';\n\nlet register;\ntry {\n  const { app } = require('electron');\n  register = app.setAsDefaultProtocolClient.bind(app);\n} catch (err) {\n  try {\n    register = require('register-scheme');\n  } catch (e) {} // eslint-disable-line no-empty\n}\n\nif (typeof register !== 'function') {\n  register = () => false;\n}\n\nfunction pid() {\n  if (typeof process !== 'undefined') {\n    return process.pid;\n  }\n  return null;\n}\n\nconst uuid4122 = () => {\n  let uuid = '';\n  for (let i = 0; i < 32; i += 1) {\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      uuid += '-';\n    }\n    let n;\n    if (i === 12) {\n      n = 4;\n    } else {\n      const random = Math.random() * 16 | 0;\n      if (i === 16) {\n        n = (random & 3) | 0;\n      } else {\n        n = random;\n      }\n    }\n    uuid += n.toString(16);\n  }\n  return uuid;\n};\n\nmodule.exports = {\n  pid,\n  register,\n  uuid: uuid4122,\n};\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nmodule.exports = exports = globalObject.fetch;\n\n// Needed for TypeScript and Webpack.\nif (globalObject.fetch) {\n\texports.default = globalObject.fetch.bind(globalObject);\n}\n\nexports.Headers = globalObject.Headers;\nexports.Request = globalObject.Request;\nexports.Response = globalObject.Response;\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst RPC = __importStar(require(\"discord-rpc\"));\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nconst gameart_json_1 = __importDefault(require(\"./gameart.json\"));\r\nconst actions_1 = require(\"./actions\");\r\nconst AppID = '594190466782724099';\r\nclass DiscordRPC {\r\n    constructor(api) {\r\n        this.enabled = false;\r\n        this.currentActivity = null;\r\n        this.clientId = null;\r\n        this.connected = false;\r\n        this.iRetryDelay = 10000;\r\n        this.iRetryDelayMax = 120000;\r\n        this.GetSettings = (api) => api.getState().settings['Discord'];\r\n        this.settingsSyncTimer = null;\r\n        this.AppId = AppID;\r\n        this.ActivityUpdateTimer = null;\r\n        this.getUser = () => this._Client.user;\r\n        this._API = api;\r\n        this.createClient();\r\n        this.Settings = this.GetSettings(api);\r\n        this._API.onStateChange(['settings', 'Discord'], () => this.scheduleSettingsSync());\r\n        this._API.events.on('gamemode-activated', (mode) => this.onGameModeActivated(mode));\r\n        this._API.events.on('did-deploy', () => this.onDidDeploy());\r\n        this._API.onStateChange(['settings', 'profiles', 'activeProfileId'], (prev, cur) => this.onActiveProfileChanged(prev, cur));\r\n        this._API.onStateChange(['session', 'base', 'toolsRunning'], (prev, cur) => this.onToolsRunningChanged(prev, cur));\r\n        this._API.onStateChange(['session', 'collections', 'activeSession'], (prev, cur) => this.onCollectionInstallProgress(prev, cur));\r\n        this._API.events.on('update-discord-activity', (presence) => this.setActivity(presence));\r\n    }\r\n    scheduleSettingsSync() {\r\n        if (this.settingsSyncTimer)\r\n            clearTimeout(this.settingsSyncTimer);\r\n        this.settingsSyncTimer = setTimeout(() => this.syncSettings(), 150);\r\n    }\r\n    syncSettings() {\r\n        this.settingsSyncTimer = null;\r\n        const newSettings = this._API.getState().settings['Discord'] || {};\r\n        const oldSettings = this.Settings || { enabled: true };\r\n        (0, vortex_api_1.log)('debug', 'Updated RPC Settings', { newSettings, oldSettings });\r\n        console.log('Updated RPC settings', newSettings);\r\n        this.Settings = newSettings;\r\n        if (newSettings.enabled !== oldSettings.enabled) {\r\n            if (newSettings.enabled) {\r\n                this.login();\r\n                const currentGame = vortex_api_1.selectors.activeGameId(this._API.getState());\r\n                this.setRPCGame(currentGame);\r\n            }\r\n            else {\r\n                this.clearActivity().catch(() => { });\r\n                this.dispose();\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    createClient() {\r\n        if (this._Client)\r\n            this._Client.removeAllListeners();\r\n        this._Client = new RPC.Client({ transport: 'ipc' });\r\n        this._Client.on('ready', () => {\r\n            const user = this._Client.user;\r\n            (0, vortex_api_1.log)('info', `Discord RPC - ${user.username} (${user.id}) logged into client ${this.clientId}`);\r\n        });\r\n        this._Client.on('error', (err) => (0, vortex_api_1.log)('error', 'Discord RPC error', err));\r\n        this._Client.on('connected', () => (0, vortex_api_1.log)('debug', 'Discord RPC connected'));\r\n        this._Client.on('disconnected', () => {\r\n            (0, vortex_api_1.log)('debug', 'Discord RPC disconnected');\r\n            this.connected = false;\r\n        });\r\n    }\r\n    async login(retryLimit = -1) {\r\n        if (this.connected)\r\n            return true;\r\n        if (!this._Client)\r\n            this.createClient();\r\n        this.iRetryAttempts = retryLimit;\r\n        this.clearRetryTimer();\r\n        try {\r\n            await this._Client.login({ clientId: this.AppId });\r\n            this.connected = true;\r\n            this.iRetryDelay = 10000;\r\n            this._API.store.dispatch((0, actions_1.setCurrentUser)(this._Client.user));\r\n            return true;\r\n        }\r\n        catch (err) {\r\n            console.warn('DPC RPC failed', err);\r\n            (0, vortex_api_1.log)('warn', 'Discord RPC failed to connect', err);\r\n            this.connected = false;\r\n            this.enabled = false;\r\n            if (retryLimit === -1 || retryLimit > 0) {\r\n                this.scheduleRetry();\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    scheduleRetry() {\r\n        this.clearRetryTimer();\r\n        const delay = Math.min(this.iRetryDelay, this.iRetryDelayMax);\r\n        this.RetryTimer = setTimeout(async () => {\r\n            this.iRetryDelay = Math.min(this.iRetryDelay + 10000, this.iRetryDelayMax);\r\n            if (this.iRetryAttempts > 0)\r\n                this.iRetryAttempts -= 1;\r\n            const ok = await this.retryLogin();\r\n            if (!ok && this.iRetryAttempts === 0)\r\n                this.clearRetryTimer();\r\n        }, delay);\r\n    }\r\n    async retryLogin() {\r\n        return this.login(this.iRetryAttempts);\r\n    }\r\n    clearRetryTimer() {\r\n        if (this.RetryTimer) {\r\n            clearTimeout(this.RetryTimer);\r\n            this.RetryTimer = null;\r\n        }\r\n    }\r\n    async clearActivity() {\r\n        this.currentActivity = null;\r\n        this.connected = false;\r\n        this._API.store.dispatch((0, actions_1.setCurrentActivity)(undefined));\r\n        this._API.store.dispatch((0, actions_1.setCurrentUser)(undefined));\r\n        await this._Client.clearActivity();\r\n    }\r\n    async onGameModeActivated(newMode) {\r\n        (0, vortex_api_1.log)('debug', 'Discord RPC updating for GameModeActivated');\r\n        return this.setRPCGame(newMode);\r\n    }\r\n    onDidDeploy() {\r\n        (0, vortex_api_1.log)('debug', 'Discord RPC updating for DidDeploy activated');\r\n        const state = this._API.getState();\r\n        const activeGameId = vortex_api_1.selectors.activeGameId(state);\r\n        this.setRPCGame(activeGameId);\r\n    }\r\n    onActiveProfileChanged(prev, cur) {\r\n        (0, vortex_api_1.log)('debug', 'Discord RPC updating for ActiveProfilChanged');\r\n        if (!cur)\r\n            return this.clearActivity();\r\n        else {\r\n            const state = this._API.getState();\r\n            const activeGameId = vortex_api_1.selectors.activeGameId(state);\r\n            this.setRPCGame(activeGameId);\r\n        }\r\n    }\r\n    onToolsRunningChanged(prev, cur) {\r\n        (0, vortex_api_1.log)('debug', 'Discord RPC updating for ToolsRunningChanged');\r\n        const prevTools = Object.keys(prev);\r\n        const nextTools = Object.keys(cur);\r\n        if (prevTools.length > 0 && nextTools.length === 0) {\r\n            const state = this._API.getState();\r\n            const activeGameId = vortex_api_1.selectors.activeGameId(state);\r\n            this.setRPCGame(activeGameId);\r\n        }\r\n        else {\r\n            this.clearActivity();\r\n        }\r\n    }\r\n    onCollectionInstallProgress(prev, cur) {\r\n        if (!cur || cur.installedCount === prev.installedCount || this.ActivityUpdateTimer) {\r\n            console.log('Aborting update as no session change or install count change or change is queued', { prev, cur, timer: this.ActivityUpdateTimer });\r\n            return;\r\n        }\r\n        const { collectionId, totalRequired, totalOptional, installedCount, gameId } = cur;\r\n        const collectionEntity = this._API.getState().persistent.mods[gameId][collectionId];\r\n        console.log('Collection session', { cur, collectionEntity });\r\n        const game = vortex_api_1.util.getGame(gameId);\r\n        const presence = {\r\n            details: `Installing collection \"${collectionEntity.attributes.customFileName}\"...`,\r\n            state: `Revision ${collectionEntity.attributes.modVersion} (${installedCount}/${totalRequired + totalOptional})`,\r\n            largeImageKey: gameart_json_1.default[game.id] || 'vortexlogo512',\r\n            largeImageText: gameart_json_1.default[game.id] ? game.name : 'Vortex',\r\n            smallImageKey: gameart_json_1.default[game.id] ? 'vortexlogo512' : 'nexuslogo',\r\n            smallImageText: gameart_json_1.default[game.id] ? 'Vortex by Nexus Mods' : 'Nexus Mods',\r\n            startTimestamp: new Date(collectionEntity.attributes.installTime),\r\n            buttons: [\r\n                {\r\n                    label: 'Get Collection',\r\n                    url: `https://www.nexusmods.com/games/${gameId}/collections/${collectionEntity.attributes.collectionSlug}`\r\n                }\r\n            ]\r\n        };\r\n        return this.setActivity(presence);\r\n    }\r\n    async setRPCGame(gameId) {\r\n        if (!this.Settings.enabled)\r\n            return;\r\n        if (!gameId) {\r\n            this.setDefaultRPC();\r\n            return;\r\n        }\r\n        const state = this._API.getState();\r\n        const game = vortex_api_1.util.getGame(gameId);\r\n        const profile = vortex_api_1.selectors.activeProfile(state);\r\n        const modCount = Object.values(profile.modState).filter(m => m.enabled).length;\r\n        (0, vortex_api_1.log)('info', `Updating Discord RPC for ${game.id}: ${profile.id}`);\r\n        const presence = {\r\n            details: game.name,\r\n            state: modCount === 1 ? `${modCount} mod installed` : `${modCount} mods installed`,\r\n            largeImageKey: gameart_json_1.default[game.id] || 'vortexlogo512',\r\n            largeImageText: gameart_json_1.default[game.id] ? game.name : 'Vortex',\r\n            smallImageKey: gameart_json_1.default[game.id] ? 'vortexlogo512' : 'nexuslogo',\r\n            smallImageText: gameart_json_1.default[game.id] ? 'Vortex by Nexus Mods' : 'Nexus Mods',\r\n        };\r\n        return this.setActivity(presence);\r\n    }\r\n    async setDefaultRPC() {\r\n        const presence = {\r\n            details: 'Vortex Mod Manager',\r\n            state: 'Ready to start modding!',\r\n            largeImageKey: 'vortexlogo512',\r\n            largeImageText: 'Vortex',\r\n            smallImageKey: 'nexuslogo',\r\n            smallImageText: 'Nexus Mods'\r\n        };\r\n        return this.setActivity(presence);\r\n    }\r\n    async setActivityImpl(presence) {\r\n        this.ActivityUpdateTimer = null;\r\n        try {\r\n            if (!this.connected) {\r\n                await this.login();\r\n                if (!this.connected)\r\n                    return;\r\n            }\r\n            if (presence) {\r\n                this.currentActivity = presence;\r\n                this._Client.setActivity(presence);\r\n                this._API.store.dispatch((0, actions_1.setCurrentActivity)(presence));\r\n            }\r\n            else {\r\n                this.clearActivity();\r\n                this._API.store.dispatch((0, actions_1.setCurrentActivity)(undefined));\r\n            }\r\n        }\r\n        catch (err) {\r\n            (0, vortex_api_1.log)('warn', 'Failed to set RPC', err);\r\n        }\r\n    }\r\n    async setActivity(presence) {\r\n        const current = this._API.getState().session['Discord'].presence;\r\n        const sameAsCurrent = JSON.stringify(current) === JSON.stringify(presence);\r\n        if (sameAsCurrent)\r\n            return;\r\n        if (this.ActivityUpdateTimer)\r\n            clearTimeout(this.ActivityUpdateTimer);\r\n        this.ActivityUpdateTimer = setTimeout((presence) => this.setActivityImpl(presence), 5000, presence);\r\n    }\r\n    dispose() {\r\n        this.clearRetryTimer();\r\n        if (this._Client) {\r\n            this._Client.removeAllListeners();\r\n            try {\r\n                if (typeof this._Client.destroy === 'function')\r\n                    this._Client.destroy();\r\n            }\r\n            catch { }\r\n            this._Client = null;\r\n        }\r\n    }\r\n}\r\nexports.default = DiscordRPC;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst react_1 = __importDefault(require(\"react\"));\r\nconst react_bootstrap_1 = require(\"react-bootstrap\");\r\nconst react_redux_1 = require(\"react-redux\");\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nconst actions_1 = require(\"./actions\");\r\nfunction DiscordSettings() {\r\n    var _a;\r\n    const { enabled } = (0, react_redux_1.useSelector)((state) => state.settings['Discord']);\r\n    const { user } = (0, react_redux_1.useSelector)((state) => state.session['Discord']);\r\n    const state = (0, react_redux_1.useSelector)((state) => state);\r\n    const store = (0, react_redux_1.useStore)();\r\n    const setRPCEnabled = react_1.default.useCallback((enabled) => {\r\n        store.dispatch((0, actions_1.setRPCSetting)('enabled', enabled));\r\n    }, []);\r\n    return (react_1.default.createElement(\"form\", null,\r\n        react_1.default.createElement(react_bootstrap_1.FormGroup, { controlId: '' },\r\n            react_1.default.createElement(react_bootstrap_1.Panel, null,\r\n                react_1.default.createElement(react_bootstrap_1.ControlLabel, null, \"Discord Integration\"),\r\n                react_1.default.createElement(vortex_api_1.Toggle, { checked: enabled, onToggle: setRPCEnabled },\r\n                    \"Enable Discord Rich Presence\",\r\n                    react_1.default.createElement(vortex_api_1.More, { id: 'discord-master-enable', name: 'Discord Rich Presence' }, \"Shows your Vortex activity in Discord for your friends to see.\")),\r\n                react_1.default.createElement(vortex_api_1.Toggle, { checked: false, disabled: !enabled, onToggle: () => undefined }, \"Show Mods\"),\r\n                react_1.default.createElement(vortex_api_1.Toggle, { checked: false, disabled: !enabled, onToggle: () => undefined }, \"Show Collections\"),\r\n                user && (react_1.default.createElement(\"div\", null,\r\n                    react_1.default.createElement(\"p\", null, \"Connected to Discord as:\"),\r\n                    react_1.default.createElement(\"div\", { style: { display: 'flex', gap: 4, justifyItems: 'center' } },\r\n                        react_1.default.createElement(\"img\", { src: `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png`, width: 20, height: 20, alt: user.username, style: { borderRadius: 25 } }),\r\n                        react_1.default.createElement(\"p\", { title: `${user.username} (${user.id})` },\r\n                            react_1.default.createElement(\"strong\", null, (_a = user.global_name) !== null && _a !== void 0 ? _a : user.username))))),\r\n                !user && react_1.default.createElement(\"p\", null, \"Not connected to Discord\")),\r\n            react_1.default.createElement(\"a\", { onClick: () => console.log(state) }, \"Print State\"))));\r\n}\r\nexports.default = DiscordSettings;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.setCurrentUser = exports.setCurrentActivity = exports.setRPCSetting = void 0;\r\nconst redux_act_1 = require(\"redux-act\");\r\nexports.setRPCSetting = (0, redux_act_1.createAction)('SET_DISCORD_RPC_SETTING', (key, value) => ({ key, value }));\r\nexports.setCurrentActivity = (0, redux_act_1.createAction)('SET_DISCORD_RPC_ACTIVITY', (presence) => ({ presence }));\r\nexports.setCurrentUser = (0, redux_act_1.createAction)('SET_DISCORD_RPC_USER', (user) => ({ user }));\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nconst reducers_1 = __importStar(require(\"./reducers\"));\r\nconst DiscordRPC_1 = __importDefault(require(\"./DiscordRPC\"));\r\nconst Settings_1 = __importDefault(require(\"./Settings\"));\r\nfunction main(context) {\r\n    let client;\r\n    context.registerSettings('Vortex', Settings_1.default, () => ({}), () => true, 150);\r\n    context.registerReducer(['settings', 'Discord'], reducers_1.default);\r\n    context.registerReducer(['session', 'Discord'], reducers_1.discordRpcSessionReducer);\r\n    context.once(async () => {\r\n        client = new DiscordRPC_1.default(context.api);\r\n        (0, vortex_api_1.log)('debug', 'Discord RPC client created');\r\n        try {\r\n            client.login();\r\n        }\r\n        catch (err) {\r\n            (0, vortex_api_1.log)('warn', 'Failed to log in to Discord via RPC', err);\r\n        }\r\n    });\r\n}\r\nexports.default = main;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.discordRpcSessionReducer = void 0;\r\nconst actions_1 = require(\"./actions\");\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nconst discordRpcReducers = {\r\n    reducers: {\r\n        [actions_1.setRPCSetting]: (state, payload) => {\r\n            return vortex_api_1.util.setSafe(state, [payload.key], payload.value);\r\n        },\r\n    },\r\n    defaults: {\r\n        enabled: true,\r\n    }\r\n};\r\nexports.discordRpcSessionReducer = {\r\n    reducers: {\r\n        [actions_1.setCurrentActivity]: (state, payload) => {\r\n            if (payload.presence)\r\n                return vortex_api_1.util.setSafe(state, ['presence'], payload.presence);\r\n            else\r\n                return vortex_api_1.util.deleteOrNop(state, ['presence']);\r\n        },\r\n        [actions_1.setCurrentUser]: (state, payload) => {\r\n            if (payload.user)\r\n                return vortex_api_1.util.setSafe(state, ['user'], payload.user);\r\n            else\r\n                return vortex_api_1.util.deleteOrNop(state, ['user']);\r\n        }\r\n    },\r\n    defaults: {}\r\n};\r\nexports.default = discordRpcReducers;\r\n","/* (ignored) */","/* (ignored) */","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"net\");","module.exports = require(\"react\");","module.exports = require(\"react-bootstrap\");","module.exports = require(\"react-redux\");","module.exports = require(\"redux-act\");","module.exports = require(\"timers\");","module.exports = require(\"vortex-api\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"ignoreList":[],"sourceRoot":""}